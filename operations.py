"""
DGPyToy/operations.py

Author: Jonah Miller (jonah.maxwell.miller@gmail.com)
Time-stamp: <2014-02-20 21:57:18 (jonah)>

This module contains methods to generate polynomials and quadrature
for DG methods in 1 dimension. It also contains elementwise opeerations.
"""


# Imports
# ----------------------------------------------------------------------
import numpy as np # Arrays 
from numpy import poly1d # A polynomial class
from numpy import linalg # Linear algebra functions
from scipy.special import jacobi # A class for Jacobi polynomials
from scipy.special import gamma # The gamma function
from dg_globals import * # Import global constants, etc.
# ----------------------------------------------------------------------


def normalized_jacobi(n,alpha,beta):
    """
    Returns a Jacobi polynomial that is appropriately normalized for
    orthonomality under integration with the correct wieght.

    Polynomials are a class in python, a powerful one.
    
    Note: not normalized for n = 0. This is to take full advantage of
    recurrence relations.
    """
    # Our polynomial
    poly = jacobi(n,alpha,beta)
    # Normalize it
    poly /= poly.normcoef
    if n == 0:
        poly *= np.sqrt(2.0**(-alpha - beta -1)*gamma(alpha+beta+2)/(gamma(alpha+1)*gamma(beta+1)))
    return poly


def normalized_legendre(n):
    """
    Returns a normalized Legendre polynomial. A special case of
    normalized_jacobi.
    """
    return normalized_jacobi(n,0,0)


def lgl_points(np):
    """
    Generates np Legendre-Gauss-Lobatto quadrature points spanning the
    interval [-1,1]. Returns a numpy array with the positions of those
    points.
    """
    # The order of the polynomial we want
    n = np - 1
    # The polynomial (1-r^2)
    one_minus_r2 = poly1d([-1,0,1])
    # The legendre polynomial we will take a derivative of
    legendre_n = normalized_legendre(n) 
    # The polynomial whose roots we care about
    f = one_minus_r2 * legendre_n.deriv()
    # Find the roots
    roots = f.r
    # Ensure the points are in a nice order
    roots.sort()
    return roots


def make_vandermonde(num_points,r):
    """
    Computes the vandermonde matrix V_{ij} = phi_j(r_i) where phi_j is
    the Legendre polynomial of order j (since j starts at zero)

    r is a vector containing the interpolating points generated by
    lgl_points. np is the order of the representation in the legendre
    basis.

    This matrix allows us to transform from lagrange polynomial
    representation to the legendre polynomial representation of the
    interpolating function for u.

    Returns an nx|r| matrix
    """
    vandermonde = np.array([[normalized_legendre(j)(r[i]) for j in range(num_points)]\
                                for i in range(len(r))])
    return vandermonde
    

def grad_jacobi(r,alpha,beta,n):
    """
    Calculates the derivative of the jacobi polynomial of type
    (alpha,beta) at points r (r is a numpy array or scalar value) for
    order n and returns the vector of derivatives.
    """
    poly = normalized_jacobi(n,alpha,beta)
    return poly.deriv()(r)


def make_grad_vandermonde(n,r):
    """
    Calculates the gradient of the modal basis (i) at (r) at order
    n. In other words, calculates the vandermonde matrix for the
    derivatives of the legendre polynomials.
    """
    # vr stands for the vandermonde gradient
    vr = np.array([[grad_jacobi(r[i],0,0,j) for j in range(n)]\
                       for i in range(len(r))])
    return vr


def make_D_matrix(n,r,v):
    """
    Makes a matrix that maps vectors represented nodally or modally on
    an element to their derivatives. n is the order of the modal
    polynomial representation. Should be the the number of nodes minus
    one. r is a vector of node coordinates on the interval [-1,1] for
    the local linear space within a node. v is the vandermonde matrix
    for the node.
    """
    vr = make_grad_vandermonde(n,r)
    DrT = linalg.solve(v.transpose(),vr.transpose())
    Dr = DrT.transpose()
    return Dr


def generate_lift_matrix(num_points,v):
    """
    Returns a linear operator, the lift matrix, which computes a
    "surface integral" term in a 1-dimensional DG formulation.

    Technical we compute the matrix inverse of the mass matrix
    right-multiplied by the surface integral operator.

    num_points is the number of nodes in an element in the nodal
    representation. v is the Vandermonde matrix.
    """
    # A linear operator that maps from node index and selects if a
    # node is on a face. Returns one if a node is, zero otherwise. 
    ematrix = np.zeros((num_points,NUM_FACES*NODES_PER_FACE))
    ematrix[0,0] = 1
    ematrix[num_points-1,1] = 1

    # Generate the lift matrix, which is the inverse of the mass
    # matrix multiplied by the ematrix
    lift = np.dot(v,np.dot(v.transpose(),ematrix))

    return lift

